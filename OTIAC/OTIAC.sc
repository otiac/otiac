OTIAC {
	var <oracle;              // The Factor Oracle instance
	var <audioBuffer;         // Circular audio buffer
	var <inputAudioBus;       // Audio bus for analysis
	var <outputTransducer;    // Output to the guitar transducer
	var <outputLeft, outputRight;   // Output to the Room (left and right channels)
	var <monitoringBusOTIAC;  // Monitor bus OTIAC, only used to monitor the generated segments
	var <bufferSize;          // Size in samples
	var <bufferWritePos;      // Current write position
	var <sampleRate;          // System sample rate

	// SOM Neural Network
	var <somBuffer;           // Buffer storing the SOM weights
	var <somNetSize;          // Size of SOM grid (e.g., 10 for 10x10)
	var <somNumNodes;         // Total number of nodes (netSize^2)
	var <somNumFeatures;      // Number of input features
	var <somTrainingCount;    // Counter for training iterations
	var <somTrainingPeriod;   // Length of training period
	var <somNeighborhood;     // Neighborhood size

	// Audio analysis
	var <synth;               // Audio input and analysis synth
	var <onsetResponder;      // OSC responder for onset detection
	var <trainingResponder;   // OSC responder for SOM training updates

	// Event storage
	var <eventList;           // List of analyzed events
	var <onsetTimes;          // Onset times in buffer
	var <onsetPositions;      // Onset positions in buffer (samples)

	// State
	var <isListening;         // Are we currently listening?
	var <isPlaying;           // Are we currently playing back?
	var <playbackSynths;      // Active playback synths for crossfading

	// Parameters
	var <minOnsetInterval;    // Minimum time between onsets (seconds)
	var <lastOnsetTime;       // Time of last onset
	var <eventCounter;        // Counter for event IDs
	var <autoRebuildInterval;  // Rebuild oracle every N events (0 = manual only)

	// Playback
	var <playbackTask;        // Task for oracle generation
	var <generationInterval;  // How often to generate (seconds)
	var <continuity;          // Oracle continuity parameter
	var <oracleLength;        // Length of the sequence generated by the oracle
	var segmentsLevel, roomLevel; // Amplitudes of the segments and the audio sent to the room

	// Drawing
	var windowClusters;
	var userView;

	*new { |bufferMinutes = 2, inputAudioBus, somNetSize = 10, outputTransducer, outputLeft, outputRight, monitoringBusOTIAC|
		^super.new.init(bufferMinutes, inputAudioBus, somNetSize, outputTransducer, outputLeft, outputRight, monitoringBusOTIAC);
	}

	init { |bufferMinutes, audioBus, netSize, outputBus, leftChannel, rightChannel, monitor|
		// Initialize ALL variables FIRST (before waitForBoot)
		inputAudioBus = audioBus ? 0; // Default to input 0
		outputTransducer = outputBus;
		outputLeft = leftChannel;
		outputRight = rightChannel;
		monitoringBusOTIAC = monitor;
		segmentsLevel = 0;
		roomLevel = 0;

		// Initialize SOM parameters
		somNetSize = netSize;
		somNumNodes = somNetSize * somNetSize;
		somNumFeatures = 20; // 2 loudness + 6 spectral + 12 MFCCs (1-12, excluding MFCC 0)
		somTrainingCount = 0;

		// SOM learning parameters
		somTrainingPeriod = 100000;    //The length of the training period
		somNeighborhood = 0.5;         //netSize * 0.5; // neighborhood size

		// Initialize state
		eventList = List.new;
		onsetTimes = List.new;
		onsetPositions = List.new;
		playbackSynths = List.new;

		isListening = false;
		isPlaying = false;

		minOnsetInterval = 0.1;
		lastOnsetTime = 0;
		eventCounter = 0;

		// Default parameters
		generationInterval = 3.0;
		continuity = 0.6;
		autoRebuildInterval = 30;  // autorebuild set to 30 events

		// boot server and create buffers
		Server.default.waitForBoot({
			sampleRate = Server.default.sampleRate;
			bufferSize = (bufferMinutes * 60 * sampleRate).asInteger;
			bufferWritePos = 0;

			// Create audio buffer, SOM buffer, and analysis synth
			this.createBuffers;

			// Setup OSC communication
			this.setupOSC;

			("\n=== OTIAC with Learning SOM initialized ===").postlnSpecial;
			("Buffer: % minutes (% samples)".format(bufferMinutes, bufferSize)).postlnSpecial;
			("SOM: % x % grid (% nodes, % features)".format(
				somNetSize, somNetSize, somNumNodes, somNumFeatures
			)).postlnSpecial;
			("Initial training length: %, neighborhood: %".format(
				somTrainingPeriod, somNeighborhood.round(0.1)
			)).postlnSpecial;
		})
	}

	createBuffers {
		Server.default.waitForBoot({
			// Audio buffer
			audioBuffer = Buffer.alloc(Server.default, bufferSize, 1);

			// SOM buffer: numNodes frames, numFeatures channels
			// Each frame is a node, each channel is a feature dimension
			somBuffer = SOMTrain.allocBuf(Server.default, somNetSize, 2, somNumFeatures);
			//Buffer.alloc(Server.default, somNumNodes, somNumFeatures);

			Server.default.sync;

			// Initialize SOM with random grid
			SOMTrain.initBufGridRand(somBuffer, somNetSize, 2); // 2D grid

			this.createAnalysisSynth;

			"Audio and SOM buffers allocated".postlnSpecial;
		});
	}

	setupOSC {
		// Responder for onset detection and classification
		onsetResponder = OSCFunc({ |msg|
			this.handleOnsetAndClassification(msg);
		}, '/onset_classified');

		// Responder for SOM training feedback
		trainingResponder = OSCFunc({ |msg|
			this.handleTrainingUpdate(msg);
		}, '/som_training');

		"OSC responders set up \n".postlnSpecial;
	}

	// Start listening and recording
	startListening {
		if (isListening) {
			"Already listening".postlnSpecial;
			^this;
		};

		if (audioBuffer.isNil) {
			"Audio buffer not ready".postlnSpecial;
			^this;
		};

		this.instantiateAnalysisSynth;
		isListening = true;

		"Started listening and learning...".postlnSpecial;
	}

	createAnalysisSynth {
		SynthDef(\OTIAC_Analysis_LearningSOM, {
			arg audioBuf, somBuf, somNet, bufSize, windowSize = 1024, trainDur = 5000, neighborhood = 0.5,
			audioBus = 0, minInterval = 0.1;
			var input, onset, fft, trigSchmidt, silence, changed;
			var loudness, truePeak, spectralShape, mfccs, pitch, hasFreq;
			var centroid, spread, skewness, kurtosis, rolloff, flatness;
			var writePos, features, clusterCoords, clusterID;
			var trainingError, remainingPoints, winnerIndex;

			// Audio input
			input = In.ar(audioBus);

			// Write to circular buffer
			writePos = Phasor.ar(0, 1, 0, bufSize);
			BufWr.ar(input, audioBuf, writePos);

			// Onset detection
			//fft = FFT(LocalBuf(windowSize), input);
			//onset = Onsets.kr(fft, 0.2, \rcomplex, relaxtime: minInterval, floor: 0.1);
			onset =  FluidNoveltyFeature.kr(input, 0, kernelSize:55, windowSize:4096, hopSize:512); //novelty feature based on Spectrum
			trigSchmidt = Schmidt.kr(onset, 0.05, 0.1);
			silence = A2K.kr(DetectSilence.ar(input, 0.001)); //silence detection
			changed = Changed.kr(trigSchmidt+silence); // Changed.kr(onset+silence);

			// Feature extraction with FluCoMa (20 features total)
			loudness = FluidLoudness.kr(input, windowSize: windowSize);
			spectralShape = FluidSpectralShape.kr(input, windowSize: windowSize);
			// mfccs without 0th coeff, so to keep only informatino about timbre
			mfccs = FluidMFCC.kr(input, numCoeffs: 13, startCoeff: 1, maxNumCoeffs: 13, windowSize: windowSize);
			mfccs = mfccs.linlin(-20, 20, 0, 1);
			# pitch, hasFreq = FluidPitch.kr(input, windowSize: windowSize);

			// Extract specific spectral shape features and nornalize them
			centroid = spectralShape[0].explin(1, 10000, 0, 1); //in Hz
			spread = spectralShape[1].explin(1, 10000, 0, 1); // in Hz
			skewness = spectralShape[2].linlin(0, 100, 0, 1); // as ratio
			kurtosis = spectralShape[3].linlin(0, 10000, 0, 1); // as ratio
			rolloff = spectralShape[4].explin(1, 20000, 0, 1); // in Hz
			flatness = spectralShape[5].linlin(-60, 0, 0, 1); // in dB

			// Combine NORMALIZED features for SOM (20 features)
			features = [
				loudness[0].linlin(-60, 0, 0, 1), loudness[1].linlin(-60, 0, 0, 1),  // loudness, truepeak
				centroid, spread, skewness, kurtosis, rolloff, flatness,
				mfccs[0..11]].flat;

			// TRAIN the SOM when onset detected
			// SOMTrain updates the buffer in-place
			// Gate it with onset so it only trains on new events
			// SOMTrain outputs: [pointsRemaining, reconError, winnerIndex]

			# remainingPoints, trainingError, winnerIndex = SOMTrain.kr(
				somBuf,              // Buffer to train (passed as argument)
				features,            // Input features (multichannel)
				somNet,              // Grid size (passed as argument)
				2,                   // Number of dimensions (2D grid)
				trainDur,            // The length of the training period;
				neighborhood,         // Neighborhood size (decreases over time)
				changed               // Gate: train when onset OR silence is detected
			);

			// CLASSIFY with SOMRd (find best matching node after training)
			clusterCoords = SOMRd.kr(somBuf, features, somNet, 2);
			clusterID = clusterCoords[0] * somNet + clusterCoords[1];

			// Send classification when onset detected
			//SendReply.kr(changed, '/onset_classified', [writePos, clusterID, clusterCoords[0], clusterCoords[1]] ++ features ++ [pitch, mfccs[12]]);
			SendReply.kr(changed, '/onset_classified', [writePos, clusterID, clusterCoords[0], clusterCoords[1]] ++ features);

			// Send training info periodically (for monitoring)
			SendReply.kr(Impulse.kr(2), '/som_training', [trainingError, winnerIndex, clusterID, remainingPoints]);

		}).add;

		"Analysis synth with Learning SOM created".postlnSpecial;
	}

	instantiateAnalysisSynth {
		var audioBusNum;
		// Kill existing synth
		if (synth.notNil) {
			synth.free;
		};

		// Update learning parameters based on training count
		//this.updateLearningParameters;

		// Get actual numbers from Bus/Buffer objects
		audioBusNum = if (inputAudioBus.isKindOf(Bus)) {
			inputAudioBus.index
		} {
			inputAudioBus
		};

		// DEBUG: Print values before creating synth
		("Creating synth with values:").postlnSpecial;
		("\taudioBuffer.bufnum: %".format(audioBuffer.bufnum)).postlnSpecial;
		("\tsomBuffer.bufnum: %".format(somBuffer.bufnum)).postlnSpecial;
		("\tsomNetSize: %".format(somNetSize)).postlnSpecial;
		("\tbufferSize: %".format(bufferSize)).postlnSpecial;
		("\taudioBusNum: %".format(audioBusNum)).postlnSpecial;

		synth = Synth(\OTIAC_Analysis_LearningSOM, [
			\trainDur, somTrainingPeriod,
			\neighborhood, somNeighborhood,
			\audioBus, audioBusNum,
			\audioBuf, audioBuffer.bufnum,
			\somBuf, somBuffer,
			\somNet, somNetSize,
			\bufSize, bufferSize,
			\minInterval, minOnsetInterval
		], addAction: 'addToTail');

		"Analysis synth instantiated".postlnSpecial;
	}

	/* OLD method I used to update the trainDur and neighborhood manually
	updateLearningParameters {
		// Decrease learning rate and neighborhood over time
		// This is a standard SOM training schedule
		var decay = 0.99; // Decay factor per event

		if (somTrainingCount > 0) {
			// Exponential decay
			somTrainingPeriod = max(0.01, 0.5 * (decay.pow(somTrainingCount)));
			somNeighborhood = max(1.0, (somNetSize * 0.5) * (decay.pow(somTrainingCount)));
		};
	}
	*/

	handleOnsetAndClassification { |msg|
		var currentTime = SystemClock.seconds;
		var duration, eventId, durationCategory;
		var bufferPos, clusterID, clusterCoords;
		var features, completeEvent;

		// Parse message: [/onset_classified, nodeID, replyID,
		//                 bufferPos, clusterID, coordX, coordY,
		//                 20 features, pitch, mfcc13]
		//if (msg.size < 29 ) {
		if (msg.size < 27 ) {  //Recap: 3 (header) + 1 (writePos) + 1 (clusterID) + 2 (coords) + 20 (features)
			"Warning: Incomplete onset message received".postlnSpecial;
			^this;
		};

		bufferPos = msg[3];
		clusterID = msg[4].asInteger;
		clusterCoords = [msg[5], msg[6]];

		// Extract all features (indices 7-28: 20 features + pitch + mfcc13) //old test
		//features = (7..28).collect { |i| msg[i] }; // old test
		//features = (7..26).collect { |i| msg[i] } ++ [msg[27], msg[28]]; // old test

		// Extract all features (indices 7-26: 20 features)
		features = (7..26).collect { |i| msg[i] };

		// Calculate duration from previous onset
		if (onsetTimes.size > 0) {
			duration = currentTime - onsetTimes.last;
		} {
			duration = 0.1;
		};

		// Categorize duration
		durationCategory = this.categorizeDuration(duration);

		// Create event ID
		eventId = eventCounter;
		eventCounter = eventCounter + 1;

		// Store onset info
		onsetTimes.add(currentTime);
		onsetPositions.add(bufferPos.asInteger);

		// Increment training count
		somTrainingCount = somTrainingCount + 1;

		/*
		// Update learning parameters for next onset
		this.updateLearningParameters;

		// Update synth parameters if it's running
		if (synth.notNil) {
			synth.set(\trainDur, somTrainingPeriod);
			synth.set(\neighborhood, somNeighborhood);
		};
		*/

		// Build complete event for Factor Oracle
		completeEvent = [
			durationCategory,
			clusterID,
			//metadataDict
			(
				originalDuration: duration,
				bufferPosition: bufferPos.asInteger,
				onsetTime: currentTime,
				somCoords: clusterCoords,
				features: features,
				trainingIteration: somTrainingCount,
				trainDur: somTrainingPeriod,
				// Named features for easy access
				loudness: features[0],
				truepeak: features[1],
				spectralCentroid: features[2],
				spread: features[3],
				skewness: features[4],
				kurtosis: features[5],
				rolloff: features[6],
				flatness: features[7],
				mfccs: features[8..19],
			)
		];

		eventList.add(completeEvent);

		// Auto-update oracle if enabled
		if (autoRebuildInterval > 0 and: { eventList.size >= 3 }) {
			if (eventList.size % autoRebuildInterval == 0) {
				this.buildOracle;
				("Oracle auto-update with % events".format(eventList.size)).postlnSpecial;
			};
		};

		lastOnsetTime = currentTime;

		("Onset %: cluster_%, %, dur=% (%)".format(
			eventId, clusterID, clusterCoords,
			duration.round(0.01), durationCategory
			//somTrainingPeriod.round(0.001), somNeighborhood.round(0.1)
		)).postlnSpecial(~otiac_logWindow);
	}

	handleTrainingUpdate { |msg|
		// Optional: monitor training progress
		var trainingError = msg[3];
		var winnerIndex = msg[4];
		var clusterID = msg[5];
		var remaining = msg[6];
		//update somTrainingPeriod for metadataDict
		somTrainingPeriod = remaining;

		// Only print occasionally to avoid spam
		if (somTrainingCount % 10 == 0) {
			("SOM training update: error=%, winner=%, cluster=%, remaining=%".format(
				trainingError.round(0.01), winnerIndex, clusterID, remaining
			)).postlnSpecial(~otiac_logWindow);
		};
	}

	categorizeDuration { |duration|
		^case
		{ duration < 0.5 } { \very_short }
		{ duration < 1.0 } { \short }
		{ duration < 3.0 } { \medium }
		{ duration < 5.0 } { \long }
		{ duration < 7.0 } { \very_long }
		{ \sustained };
	}

	// Build Factor Oracle from collected events
	buildOracle {
		if (eventList.size < 3) {
			"Need at least 3 events to build oracle".postlnSpecial;
			^this;
		};

		oracle = FactorOracle.newFromEvents(eventList.asArray);
		("Factor Oracle built with % events".format(eventList.size)).postlnSpecial;
		("SOM has been trained on % examples".format(somTrainingCount)).postlnSpecial;
		oracle.analyze.keysValuesDo { |key, value|
			("\t%: %".format(key, value)).postlnSpecial;
		};
	}

	// Start playback (generates from oracle periodically)
	startPlayback { |interval = nil, continuityValue = nil, contextSize = 1|
		if (oracle.isNil) {
			"No oracle available. Build oracle first.".postlnSpecial;
			^this;
		};

		if (isPlaying) {
			"Already playing".postlnSpecial;
			^this;
		};

		if (interval.notNil) { generationInterval = interval };
		if (continuityValue.notNil) { continuity = continuityValue };

		isPlaying = true;

		playbackTask = Task({
			inf.do {
				if (isPlaying.not) { ^nil };

				// Generate a phrase from the oracle using context
				this.generateAndPlay(oracleLength, contextSize);

				generationInterval.wait;
			};
		});

		playbackTask.play;
		"Playback started".postlnSpecial;
	}

	generateAndPlay { arg length, contextSize = 1;
		var events, contextPitches, contextRhythm;

		// Build context from last N events
		if (eventList.size >= contextSize) {
			var lastEvents = eventList[eventList.size - contextSize..];
			contextRhythm = lastEvents.collect { |event| event[0] }; // duration categories
			contextPitches = lastEvents.collect { |event| event[1] }; // cluster IDs

			events = oracle.generateFromContext(
				contextPitches,
				contextRhythm,
				length,
				continuity
			).asArray;
		} {
			// Fallback to regular generate if not enough events
			("Not enough events for context (need %, have %). Using .generate instead".format(
				contextSize, eventList.size
			)).postlnSpecial;
			events = oracle.generate(length, continuity).asArray;
		};

		if (events.size > 0) {
			("Generating phrase with % events (context size: %)".format(
				events.size, contextSize
			)).postlnSpecial;
			this.playEventSequence(events);
		};
	}

	playEventSequence { |events|
		var playTask;

		playTask = Task({
			events.do { |event, i|
				var durationCategory, clusterID, eventIndex, actualDuration;

				if (isPlaying.not) { ^nil };

				// Generated events are [durationCategory, clusterID]
				durationCategory = event[0];
				clusterID = event[1];

				// Find matching recorded event
				eventIndex = this.findMatchingEventIndex(durationCategory, clusterID);

				if (eventIndex.notNil) {
					actualDuration = eventList[eventIndex][2].originalDuration;
					this.playAudioSegment(eventIndex, actualDuration);
					("Actual duration: "++actualDuration).postlnSpecial;
					actualDuration.wait;
				} {
					0.1.wait;
				};
			};
		});

		playTask.play;
	}

	findMatchingEventIndex { |targetDuration, targetCluster|
		var matchingIndices, bestIndex;

		// Find all events with matching cluster
		matchingIndices = eventList.selectIndices { |event|
			event[1] == targetCluster
		};

		// If found matches, choose one (optionally prefer matching duration)
		if (matchingIndices.size > 0) {
			// Try to match duration category too
			var durationMatches = matchingIndices.select { |idx|
				eventList[idx][0] == targetDuration
			};

			bestIndex = if (durationMatches.size > 0) {
				durationMatches.choose
			} {
				matchingIndices.choose
			};
		} {
			// No matching cluster - choose random event as fallback
			bestIndex = eventList.size.rand;
			("Warning: No match for cluster %, using random event".format(targetCluster)).postlnSpecial;
		};

		^bestIndex;
	}

	playAudioSegment { |eventIndex, duration|
		var event, bufferPos, nextBufferPos, segmentLength, playbackSynth;
		var fadeTime = 0.1;

		if (eventIndex >= eventList.size) { ^this };

		event = eventList[eventIndex];
		bufferPos = event[2].bufferPosition;

		// Calculate segment length
		if ((eventIndex + 1) < eventList.size) {
			nextBufferPos = eventList[eventIndex + 1][2].bufferPosition;
			segmentLength = min(duration * sampleRate, nextBufferPos - bufferPos);
		} {
			segmentLength = duration * sampleRate;
		};

		segmentLength = max(segmentLength, 1024);

		playbackSynth = {
			var sig, env;

			sig = PlayBuf.ar(1, audioBuffer, 1, 1, bufferPos);
			env = EnvGen.kr(
				//Env([0, 1, 1, 0], [fadeTime, duration-(5*fadeTime), 4*fadeTime], curve:[-5, 0, 5]),
				Env.linen(duration*0.4, duration*0.2, duration*0.4, curve:\welch),
				doneAction: 2
			);
			// Out to monitoring bus
			Out.ar(monitoringBusOTIAC, sig*env);
			// Out to guitar transducer
			Out.ar(outputTransducer, sig*env*0.9);
			// Out to the Room
			Out.ar(outputLeft, sig*env, 0.9);
		}.play;

		playbackSynths.add(playbackSynth);

		SystemClock.sched(duration + 0.1, {
			playbackSynths.remove(playbackSynth);
			nil;
		});

		("Playing: event % (cluster %, %), dur=%s".format(
			eventIndex, event[1], event[0], duration.round(0.01)
		)).postlnSpecial;
	}


	stopListening {
		if (isListening.not) {
			"Not currently listening".postlnSpecial;
			^this;
		};

		isListening = false;

		if (synth.notNil) {
			synth.free;
			synth = nil;
		};

		"Stopped listening".postlnSpecial;
	}

	stopPlayback {
		if (playbackTask.notNil) {
			playbackTask.stop;
			playbackTask = nil;
		};

		playbackSynths.do { |synth| synth.free };
		playbackSynths.clear;

		isPlaying = false;
		"Playback stopped".postlnSpecial;
	}

	// Parameter setters
	setSegmentsLevel {|amplitude|
		segmentsLevel = amplitude.lag(0.1);
	}

	setRoomLevel {|amplitude|
		roomLevel = amplitude.lag(0.1);
	}

	setContinuity { |value|
		continuity = value.clip(0, 1);
		//("Continuity set to %".format(continuity)).postlnSpecial;
	}

	setOracleLength { |value|
		oracleLength = value;
		("FO Length set to %".format(oracleLength)).postlnSpecial;
	}

	setGenerationInterval { |seconds|
		generationInterval = seconds;
		//("Generation interval set to %s".format(generationInterval)).postlnSpecial;
	}

	setMinOnsetInterval { |seconds|
		minOnsetInterval = seconds;
		("Minimum onset interval set to %s".format(minOnsetInterval)).postlnSpecial;
	}

	// Status and analysis
	status {
		"\n=== OTIAC Status ===".postlnSpecial;
		("Listening: %".format(isListening)).postlnSpecial;
		("Playing: %".format(isPlaying)).postlnSpecial;
		("Total events: %".format(eventList.size)).postlnSpecial;
		("SOM training iterations: %".format(somTrainingCount)).postlnSpecial;
		("Current learning rate: %".format(somTrainingPeriod.round(0.0001))).postlnSpecial;
		("Current neighborhood: %".format(somNeighborhood.round(0.1))).postlnSpecial;
		("Oracle available: %".format(oracle.notNil)).postlnSpecial;
		("Buffer size: % samples (% minutes)".format(
			bufferSize, (bufferSize / sampleRate / 60).round(0.1)
		)).postlnSpecial;
		("SOM: % x % (% nodes)".format(somNetSize, somNetSize, somNumNodes)).postlnSpecial;
		("Continuity: %".format(continuity)).postlnSpecial;
		("Generation interval: %s".format(generationInterval)).postlnSpecial;
		("Auto-update: %".format(
			if (autoRebuildInterval > 0) {
				"every % events".format(autoRebuildInterval)
			} { "manual only" }
		)).postlnSpecial;

		if (oracle.notNil) {
			"\nOracle analysis:".postlnSpecial;
			oracle.analyze.keysValuesDo { |key, value|
				("\t%: %".format(key, value)).postlnSpecial;
			};
		};
	}

	printEvents {
		"=== Audio Events ===".postlnSpecial;
		eventList.do { |event, i|
			var durCat = event[0];
			var cluster = event[1];
			var features = event[2];

			("Event %: cluster_%, %, dur=%s (%), LR=% [iter %]".format(
				i, cluster, features.somCoords,
				features.originalDuration.round(0.01), durCat,
				features.trainDur.round(0.0001),
				features.trainingIteration
			)).postlnSpecial;
		};
	}

	printClusterDistribution {
		var clusterCounts = Dictionary.new;

		eventList.do { |event|
			var cluster = event[1];
			clusterCounts[cluster] = (clusterCounts[cluster] ? 0) + 1;
		};

		"\n=== Cluster Distribution ===".postlnSpecial;
		clusterCounts.keys.asArray.sort.do { |cluster|
			var count = clusterCounts[cluster];
			var percentage = (count / eventList.size * 100).round(0.1);
			("Cluster %: % events (%%)".format(cluster, count, percentage)).postlnSpecial;
		};
	}

	drawClusterDistribution {
		{
			var cellSize = 600 / somNetSize;

			// Close existing window if present
			if (windowClusters.notNil and: { windowClusters.isClosed.not }) {
				windowClusters.close;
			};

			windowClusters = Window("Cluster Distribution", Rect(200, 800, 600, 600)).alwaysOnTop_(true);
			userView = UserView(windowClusters, windowClusters.view.bounds);

			userView.drawFunc = {
				// Recalculate counts EVERY time we draw
				var clusterCounts = Dictionary.new;
				var maxCount = 1;

				eventList.do { |event|
					var cluster = event[1];
					clusterCounts[cluster] = (clusterCounts[cluster] ? 0) + 1;
				};

				if (clusterCounts.size > 0) {
					maxCount = clusterCounts.values.maxItem;
				};

				somNumNodes.do { |clusterID|
					var x = (clusterID % somNetSize) * cellSize;
					var y = (clusterID div: somNetSize) * cellSize;
					var count = clusterCounts[clusterID] ? 0;
					var intensity = if (maxCount > 0) { count / maxCount } { 0 };

					// Draw colored square (more events = brighter)
					Pen.fillColor = Color.blue(1, intensity);
					Pen.fillRect(Rect(x, y, cellSize, cellSize));

					// Draw border
					Pen.strokeColor = Color.gray(0.3);
					Pen.strokeRect(Rect(x, y, cellSize, cellSize));

					// Draw count
					if (count > 0) {
						Pen.stringAtPoint(count.asString,
							(x + (cellSize/2)-10)@(y + (cellSize/2)-5),
							Font("Baskerville", 14), Color.gray(intensity));
					};
				};
			};

			windowClusters.front;
		}.defer;
	}

	refreshClusterDistribution {
		if (userView.notNil) {
			userView.refresh; //redraw the cluster distributions
		} {
			"No cluster window open. Call drawClusterDistribution first.".postlnSpecial;
		};
	}


	// Draw the Oracle using the FactorOracleView
	drawOracle { |windowName, width = 1400, height = 500|
		if (oracle.isNil) {
			"No oracle available. Build oracle first.".postlnSpecial;
			^nil;
		};

		^FactorOracleView(
			oracle,
			name: windowName ?? "OTIAC Oracle",
			windowWidth: width,
			windowHeight: height
		);
	}

	setAutoRebuild { |interval|
		autoRebuildInterval = interval;
		if (interval > 0) {
			("Auto-update enabled: every % events".format(interval)).postlnSpecial;
		} {
			"Auto-update disabled (manual only)".postlnSpecial;
		};
	}

	// Save the trained SOM to disk
	saveSOM { |path|
		somBuffer.write(path, "wav", "float");
		("SOM saved to: %".format(path)).postlnSpecial;
	}

	// Load a pre-trained SOM from disk
	loadSOM { |path|
		somBuffer.read(path, action: {
			"SOM loaded from disk".postlnSpecial;
		});
	}

	// Cleanup
	free {
		this.stopListening;
		this.stopPlayback;

		if (onsetResponder.notNil) { onsetResponder.free };
		if (trainingResponder.notNil) { trainingResponder.free };
		if (audioBuffer.notNil) { audioBuffer.free };
		if (somBuffer.notNil) { somBuffer.free };

		"OTIAC freed".postlnSpecial;
	}
}
